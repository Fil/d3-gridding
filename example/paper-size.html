<!DOCTYPE html>
<meta charset="utf-8">
<style>
body {
  font-family: Helvetica;
  font-size: 10px;
}
.point {
  fill: black;
}

rect, circle {
  stroke: black;
  stroke-width: 1;
}

.title {

}

</style>
<body>
<script src="http://d3js.org/d3.v4.js"></script>
<script src="../build/d3-gridding.js"></script>
<script>

var width = 400,
    height = 300;

var gridding = d3.gridding()
  .size([width, height]);
//  .value(function(d) { return d.index; });

var svgSquares = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g");

var color = d3.scaleLinear()
    .domain([0, 10])
    .range(["black", "white"]);

function generateData(n, offset) {
  offset = offset || 0;
  return d3.range(n).map(function(d, i) {
    return {x: d, y: i, r: Math.random(), index: i + offset, group: i % 10};
  });
}

function render(el, griddingData, depth, key) {

  var squares = el.selectAll(".square.depth_" + depth)
    .data(griddingData, function(d) { return d.index; });

  squares.enter().append("rect")
    .attr("class", "square depth_" + depth)
    .attr("width", function(d) { return d.width; })
    .attr("height", function(d) { return d.height; })
    .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
    .style("fill", "none")//function(d, i) { return color(d.index); })
    .style("fill-opacity", .8);

  if(depth > 0) {
    squares.exit().remove();
  }

  squares.transition()
    .attr("width", function(d) { return d.width; })
    .attr("height", function(d) { return d.height; })
    .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

}

var n = 25;

var groups = d3.range(10).map(function(d, i) {
  return function(_) { return _.index < d; }
});

var data = generateData(220);

function update() {


/*
  var griddings = griddingDataGroups.map(function(d, i) {

    var grid = d3.gridding()
      .size([d.width, d.height])
      .offset([d.x, d.y])
      .mode("grid")
      .padding(0);

      // Recursive nesting????

    render(svgSquares, grid(nested_data[i].values), 0);
  });
*/


  var dataGridding = gridding([{}]);

  var context = [{x: 0, y: 0, height: 0, width: 0}];

  // Each data is implicitely a level of grouping / nesting
  data.forEach(function(d, i) {

    var nested_data = d3.nest()
        .key(groups[i])
        .entries(data);

    gridding
      .mode(i % 2 === 0 ? "vertical": "horizontal")
      .padding(10);

    var griddingDataGroups = gridding(nested_data);

    // Get the latest group only
    var griddings = griddingDataGroups[griddingDataGroups.length - 1];

      var grid = d3.gridding()
        .size([griddings.width, griddings.height])
        .offset([griddings.x, griddings.y])
        .mode("horizontal")
        .padding(0);

      render(svgSquares, grid(nested_data), 0);

//    render(svgSquares, griddingDataGroups, i + 1);


  })

}

var timing = 0, duration = 2000;

// Grouping
setTimeout(function() {data = generateData(1); update("grid", groups[0]); }, timing++ * duration);
setTimeout(function() {data = generateData(2); update("grid", groups[1]); }, timing++ * duration);
setTimeout(function() {data = generateData(3); update("grid", groups[2]); }, timing++ * duration);


</script>
